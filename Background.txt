###############################
# Buffer Overflow Background #
#############################

# Introduction #
In this context a buffer is a span of memory that is "reserved" for some set of data. Reserved here is in quotations because at lower levels reservation of space is typcially by convention and contract only. Flawed implementations of this contract can lead to vulnerabilities like the buffer overflow

# The Stack #
The stack is a data structure you should have learned about in a previous course. Its a variable length structure and in this context you can think of it as growing upward toward lower addresses. In practice, a simplified version might look something like this:
         Address     Data
 Top     0x00004124  0xAAAA        
         0x00004128  0xBBBB
         ...
         0x000042F8  0xFAAA
 Bottom  0x000042FC  0xFBBB       

In a program a stack is used to keep track of local variables and general data that a function needs to execute in a well-behaved manner with other functions. When you call a function some space is allocated on the stack by substracting some amount from the stack pointer-- adding free space to the top of the stack. The stack pointer is a register that holds the address of the current top of the stack. Data can also be pushed onto the stack. Pushing and popping instructions increment and decrement the stack pointer respectively. When the function exits the same amount is added back to the stack pointer, or pop instructions are used, to effectively "remove" that space. In this way the stack expands and contracts as fucntions are called. 

Some function calling conventions, names x86, a arguments are pushed onto the stack prior to the function call. After the function is called space is made, by subtraction a value from the stack pointer, for local variables. In ARM the function calling convention only uses stack space if the there are more than 3 arguments.

Suppose we have a very simple C function:

  int my_func(int A) { // A = 0xAA
    int C = 0xCC;
    int B = 0xBB;
    return B;
  }

Before the program enters this function the argument A will be push on the stack. Then when the function is entered 4 bytes, or 8 if 64 bit, will be subtracted from the stack pointer for each local variable. Then the value(s) is moved onto the stack. The stack will look something like:

  ...   
  0xBB  // First local variable; Value at the top of the stack
  0xCC  // Second local variable
  0xAA  // First argument 
  ...
        // Rest of stack

# A Buffer Overflow #
If int C in my_func from the previous section was instead an eight byte character array, the space for this array would be on the stack.
  
  int my_func1(int A) { // A = 0xAA
    int B = 0xBB;
    char C[8];
    return B;
  }

 0x00004124 .. .. .. .. // Space for eight
 0x00004128 .. .. .. .. // bytes of the char array
 0x0000412C BB 00 00 00 // First local variable
 ...

When writing data to a buffer, and in general, the first byte is written at address X and the next byte at X+4. In the above example the twelfth byte will be at address 0x0000412B. The address just before the space for int B. If a function or logic were present that implemented the space reservation contracts incorrectly then we can write past 0x0000412B and alter the data contained in the space for int B.

The C function strcpy takes a string and copies it to another part of memory. It takes two arguments: destination and source. There are no bounds checks on the write. That is to say it will copy the contents of the source to the destination, byte by byte, until it comes across a null character used to terminate a string. The user of strcpy is expected to check that the string contained in the source will fit in the destination buffer. If it doesnt strcpy is content to continue writing bytes until it either reaches the end of the string or causes an error (sementation fault). 

Using strcpy we can create a my_func2 that will overwrite the local variable B. 

  int my_func2(char *A) {
    int B = 0xBB;
    char C[8];
    // Stack before strcpy
    strcpy(C, A);
    //  Stack after strcpy

    return B;
  }

Suppose A = "AAAAAAAAA" (9 bytes). This is larger than the space allocated for C by 1 bytes-- it doesnt fit. 
  Stack before strcpy
    0x00004124 .. .. .. ..
    0x00004128 .. .. .. ..
    0x0000412c BB 00 00 00 
      ........ .. .. .. .. 
      // Rest of stack....

Then strcpy moves A into C
  Stack after strcpy
    0x00004124 41 41 41 41 // 0x41 = 'A'
    0x00004128 41 41 41 41
    0x0000412c 41 00 00 00 
      ........ .. .. .. .. 
      // Rest of stack....

Strcpy have overwritten the value in int B giving it a new value of 0x41! We can do the same with 10 bytes or more. There is a limitation associated with strcpy when trying to exploit a buffer overflow vulnerability. The buffer can only be written with printable ascii characters. This may sometimes be enough though. 

  int my_func3(char *A) {
    int B = 0x00;
    char C[8];

    strcpy(C, A);

    if B != 0 {
      inaccessable_function();
    }

    return B;
  }

At a glance it appears as though inaccessable_function() should never be executed. This is becasue we initialize B to zero, never again write to it, then test if B is not zero. However, as we showed above, we can overwrite B with a non-zero value. This is probably not what the programmer would have intended but due to the ordering of the local variables on the stack and the vulnerable strcpy we can alter the value of B and get access to the inaccessable_function. 
    
A mitigation for this would be to change the order of the local variables. This would place B above C on the stack. Then when C overflows down the stack, B is out of the vulnerable stack space. With this change, the inaccessable_function would be inaccessable. 

Local variables are not the only thing stored on the stack. When you enter a function the address of the next instruction is pushed onto the stack, before local variables, to be saved. Then the function exits it pops the address off the stack into the lr register (ARM) or eip/rip (x86/64). 
  Stack of my_func3 after pushing local variables to stack
    0x00004124 00 00 00 00
    0x00004128 .. .. .. ..
    0x0000412C .. .. .. ..
    0x00004130 48 93 7f 00 // lr value prior entering my_func3
    .......... .. .. .. ..
    // Rest of stack

If this value is corrupted during function execution it will get popped off the stack and the CPU will try to execute the the corrupted value. Should the corrupted value be a valid instruction address the CPU will execute it however if it is not a valid address it will crash the program. This could allow us to control what code the CPU executes! 

Unfortunately, we cant mitigate this by reordering any local variables. However, if we expect their to be an overflow we could place a special value, we know before hand, on the stack between the lr register and the local variables we can test it before the function exits. If the value isnt what we expected we can determine there was a stack overflow and prevent the function from returning by thowing an error. This will stop any overflow from executing unauthorized instructions. This special value is called a Stack Canary or Stack Cookie.

# Stack Canaries #













